<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ÊàëÂéªÊä¢‰∏™Â∫ß - WebÁâà</title>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      padding: 20px;
      max-width: 650px;
      margin: 20px auto;
      background-color: #f4f7f9;
      color: #333;
    }

    h1,
    h2 {
      color: #2c3e50;
      text-align: center;
    }

    form {
      background-color: #fff;
      padding: 25px;
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }

    label {
      display: block;
      margin-top: 15px;
      margin-bottom: 5px;
      font-weight: bold;
      color: #34495e;
    }

    input[type=text],
    input[type=number],
    select {
      width: calc(100% - 22px);
      padding: 10px;
      margin-top: 5px;
      border: 1px solid #dcdcdc;
      border-radius: 4px;
      box-sizing: border-box;
      font-size: 1rem;
    }

    input:focus,
    select:focus {
      border-color: #007bff;
      outline: none;
      box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25);
    }

    button {
      display: block;
      width: 100%;
      padding: 12px 25px;
      margin-top: 25px;
      cursor: pointer;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 1.1rem;
      transition: background-color 0.2s ease;
    }

    button:hover:not(:disabled) {
      background-color: #0056b3;
    }

    button:disabled {
      background-color: #cccccc;
      cursor: not-allowed;
    }

    /* Modified #result for log display */
    #result {
      margin-top: 25px;
      padding: 15px;
      border: 1px solid #ccc;
      min-height: 100px;
      /* Adjusted min-height */
      max-height: 400px;
      /* Added max-height for scrolling */
      overflow-y: auto;
      /* Added scrollbar when needed */
      background-color: #f9f9f9;
      border-radius: 4px;
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.95rem;
      line-height: 1.4;
      /* white-space: pre-wrap; removed here, set on individual lines */
      word-wrap: break-word;
    }

    /* Styling for individual log lines */
    #result p {
      margin: 3px 0;
      /* Spacing between log lines */
      white-space: pre-wrap;
      /* Ensure whitespace is preserved */
    }

    .success {
      border-color: #28a745;
      /* Background set by last result line if desired, or keep parent background */
    }

    #result.success p:last-child {
      /* Style last line for success */
      color: #155724;
      background-color: #d4edda;
      padding: 3px 5px;
      border-radius: 3px;
    }

    .error {
      border-color: #dc3545;
    }

    #result.error p:last-child {
      /* Style last line for error */
      color: #721c24;
      background-color: #f8d7da;
      padding: 3px 5px;
      border-radius: 3px;
    }

    .info {
      border-color: #17a2b8;
      /* color: #0c5460; */
      /* background-color: #d1ecf1; */
    }

    .processing {
      border-color: #ffc107;
      /* color: #856404; */
      /* background-color: #fff3cd; */
    }

    /* Modified spinner for inline use */
    .spinner {
      border: 3px solid rgba(0, 0, 0, 0.1);
      /* Slightly thinner */
      width: 14px;
      /* Slightly smaller */
      height: 14px;
      /* Slightly smaller */
      border-radius: 50%;
      border-left-color: #007bff;
      margin-right: 8px;
      display: inline-block;
      /* Changed to inline-block */
      vertical-align: middle;
      /* Align vertically */
      animation: spin 1s ease infinite;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }
      100% {
        transform: rotate(360deg);
      }
    }

    small {
      color: #6c757d;
      display: block;
      margin-top: 3px;
      font-size: 0.85em;
    }

    body { 
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; 
      padding: 20px; 
      max-width: 650px; 
      margin: 20px auto; 
      background-color: #f4f7f9; 
      color: #333; 
    }

    h1,
    h2 { 
      color: #2c3e50; 
      text-align: center; 
    }

    form { 
      background-color: #fff; 
      padding: 25px; 
      border-radius: 8px; 
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1); 
    }

    label { 
      display: block; 
      margin-top: 15px; 
      margin-bottom: 5px; 
      font-weight: bold; 
      color: #34495e; 
    }

    input[type=text], input[type=number], select { 
      width: calc(100% - 22px); 
      padding: 10px; 
      margin-top: 5px; 
      border: 1px solid #dcdcdc; 
      border-radius: 4px; 
      box-sizing: border-box; 
      font-size: 1rem; 
    }

    input:focus, select:focus { 
      border-color: #007bff; 
      outline: none; 
      box-shadow: 0 0 0 2px rgba(0, 123, 255, 0.25); 
    }

    button { 
      display: block; 
      width: 100%; 
      padding: 12px 25px; 
      margin-top: 25px; 
      cursor: pointer; 
      background-color: #007bff; 
      color: white; 
      border: none; 
      border-radius: 4px; 
      font-size: 1.1rem; 
      transition: background-color 0.2s ease; 
    }

    button:hover:not(:disabled) { 
      background-color: #0056b3; 
    }

    button:disabled { 
      background-color: #cccccc; 
      cursor: not-allowed; 
    }

    #result { 
      margin-top: 25px; 
      padding: 15px; 
      border: 1px solid #ccc; 
      min-height: 100px; 
      max-height: 400px; 
      overflow-y: auto; 
      background-color: #f9f9f9; 
      border-radius: 4px; 
      font-family: 'Courier New', Courier, monospace; 
      font-size: 0.95rem; 
      line-height: 1.4; 
      word-wrap: break-word; 
    }

    #result p { 
      margin: 3px 0; 
      white-space: pre-wrap; 
    }

    .success { 
      border-color: #28a745; 
    }

    #result.success p:last-child { 
      color: #155724; 
      background-color: #d4edda; 
      padding: 3px 5px; 
      border-radius: 3px; 
    }

    .error { 
      border-color: #dc3545; 
    }

     #result.error p:last-child, #result p.error-message { 
      color: #721c24; 
      background-color: #f8d7da; 
      padding: 3px 5px; 
      border-radius: 3px; 
    } /* Style for error messages */

    .info { 
      border-color: #17a2b8; 
    }

    .processing { 
      border-color: #ffc107; 
    }

    .spinner { 
      border: 3px solid rgba(0, 0, 0, 0.1); 
      width: 14px; 
      height: 14px; 
      border-radius: 50%; 
      border-left-color: #007bff; 
      margin-right: 8px; 
      display: inline-block; 
      vertical-align: middle; 
      animation: spin 1s ease infinite; 
    }

    @keyframes spin { 
      0% { 
        transform: rotate(0deg); 
      } 
      100% { 
        transform: rotate(360deg); 
      } 
    }

    small { 
      color: #6c757d; 
      display: block; 
      margin-top: 3px; 
      font-size: 0.85em; 
    }

    /* Style for disconnected message */
    #result p.disconnected-message { 
      color: #6c757d; 
      font-style: italic; 
    }

  </style>
</head>

<body>
  <h1>ÊàëÂéªÊä¢‰∏™Â∫ß v2.1.0üìö</h1>
  <form id="seatForm">
    <!-- Form elements remain the same -->
    <label for="mode">Êìç‰ΩúÊ®°Âºè:</label>
    <select id="mode" name="mode" required onchange="updateWebForm()">
      <option value="1">ÊòéÊó•È¢ÑÁ∫¶ (21:48-23:59)</option>
      <option value="2" selected>Á´ãÂç≥Êä¢Â∫ß (06:30-22:30)</option>
    </select>
    <label for="cookieStr">Cookie:</label>
    <input type="text" id="cookieStr" name="cookieStr" required placeholder="Âú®Ê≠§Á≤òË¥¥ÂÆåÊï¥ÁöÑ Cookie Â≠óÁ¨¶‰∏≤">
    <label for="libId">ÈòÖËßàÂÆ§:</label>
    <select id="libId" name="libId" required>
      <option value="" disabled selected>Ê≠£Âú®Âä†ËΩΩÈòÖËßàÂÆ§...</option>
    </select>
    <label for="timeStr" id="time_label">Êä¢Â∫ßÊâßË°åÊó∂Èó¥ (ÁïôÁ©∫ÂàôÁ´ãÂç≥ÊâßË°å):</label>
    <input type="text" id="timeStr" name="timeStr" pattern="\d{2}:\d{2}:\d{2}" placeholder="HH:MM:SS">
    <small id="time_hint"></small>
    <label for="seatNumber" id="seat_label">Â∫ß‰ΩçÂè∑:</label>
    <input type="text" id="seatNumber" name="seatNumber" required placeholder="‰æãÂ¶Ç 127">
    <button type="submit" id="submitBtn" disabled>ËøûÊé•‰∏≠...</button>
  </form>

  <h2>Êìç‰ΩúÁä∂ÊÄÅ‰∏éÁªìÊûú:</h2>
  <div id="result" class="info">Á≠âÂæÖËøûÊé•Áä∂ÊÄÅÊõ¥Êñ∞ÈÄöÈÅì...</div>

  <script>
    // --- Get DOM Elements ---
    const modeSelect = document.getElementById('mode');
    const cookieInput = document.getElementById('cookieStr');
    const roomSelect = document.getElementById('libId');
    const timeLabel = document.getElementById('time_label');
    const timeInput = document.getElementById('timeStr');
    const timeHint = document.getElementById('time_hint');
    const seatLabel = document.getElementById('seat_label');
    const seatNumberInput = document.getElementById('seatNumber');
    const seatForm = document.getElementById('seatForm');
    const resultDiv = document.getElementById('result');
    const submitButton = document.getElementById('submitBtn');

    let websocket = null;
    // Generate clientId ONCE per page load
    const clientId = 'client_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);
    let wsReady = false;
    let wsConnectionAttempted = false;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5; // Max attempts before giving up temporarily
    let reconnectTimeoutId = null; // To store setTimeout ID for retries
    let isManualDisconnect = false; // Flag to prevent reconnect on intentional close

    // --- Helper function to add messages to the result div ---
    function addResultMessage(message, type = 'info', includeSpinner = false) {
      const line = document.createElement('p');
      if (includeSpinner) {
        line.innerHTML = '<div class="spinner"></div> ';
      }
      line.appendChild(document.createTextNode(message));

      // Add specific classes for styling
      if (type === 'error') {
        line.classList.add('error-message'); // Specific class for errors
      } else if (type === 'disconnected') {
        line.classList.add('disconnected-message'); // Specific class for disconnect
      }

      resultDiv.appendChild(line);
      resultDiv.scrollTop = resultDiv.scrollHeight; // Auto-scroll
    }


    // --- WebSocket Setup with Reconnect Logic ---
    function connectWebSocket() {
      // Prevent multiple connection attempts simultaneously
      if (wsConnectionAttempted) {
        console.log("WebSocket connection attempt already in progress or active.");
        return;
      }
      wsConnectionAttempted = true;
      isManualDisconnect = false; // Reset manual disconnect flag on new attempt

      const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      // Use the SAME clientId for reconnection attempts
      const wsUrl = `${wsProtocol}//${window.location.host}/ws/${clientId}`;
      console.log(`Attempting WebSocket connection (Attempt ${reconnectAttempts + 1})...`, wsUrl);

      // Clear previous messages only on the *first* attempt after a full disconnect/page load
      // Keep logs during reconnection attempts
      if (reconnectAttempts === 0 && !resultDiv.querySelector('p')) { // Only clear if empty
        resultDiv.innerHTML = '';
      }
      addResultMessage('Ê≠£Âú®ËøûÊé•Áä∂ÊÄÅÊõ¥Êñ∞ÈÄöÈÅì...', 'info', true);
      resultDiv.className = 'info'; // Reset container class
      submitButton.textContent = 'ËøûÊé•‰∏≠...';
      submitButton.disabled = true;

      // Clear any pending reconnect timeout
      if (reconnectTimeoutId) {
        clearTimeout(reconnectTimeoutId);
        reconnectTimeoutId = null;
      }

      try {
        websocket = new WebSocket(wsUrl);

        websocket.onopen = () => {
          console.log('WebSocket Connected');
          wsReady = true;
          wsConnectionAttempted = false; // Allow new attempts if needed later
          reconnectAttempts = 0; // Reset counter on successful connection

          // Remove "connecting..." messages if any
          const connectingMessages = resultDiv.querySelectorAll('p');
          connectingMessages.forEach(p => {
            if (p.textContent.includes('Ê≠£Âú®ËøûÊé•') || p.textContent.includes('Ê≠£Âú®Â∞ùËØïÈáçÊñ∞ËøûÊé•')) {
              p.remove();
            }
          });

          addResultMessage('‚úÖ ÈÄöÈÅìÂ∑≤ËøûÊé•„ÄÇ', 'info'); // Concise connected message
          resultDiv.className = 'info'; // Or keep 'processing' if an operation was ongoing
          submitButton.textContent = 'ÂºÄÂßãÊâßË°å';
          submitButton.disabled = false;
        };

        websocket.onmessage = (event) => {
          console.log('WebSocket Message:', event.data);
          wsConnectionAttempted = false; // Message received, connection is active
          try {
            const data = JSON.parse(event.data);

            if (data.type === 'status') {
              // --- Append status messages ---
              const statusLine = document.createElement('p');
              statusLine.innerHTML = '<div class="spinner"></div> ';
              statusLine.appendChild(document.createTextNode(data.message));
              resultDiv.appendChild(statusLine);
              resultDiv.scrollTop = resultDiv.scrollHeight;
              resultDiv.className = 'processing';
              submitButton.disabled = true;
              submitButton.textContent = 'Â§ÑÁêÜ‰∏≠...';

            } else if (data.type === 'result') {
              // --- Handle final result ---
              const spinners = resultDiv.getElementsByClassName('spinner');
              while (spinners.length > 0) {
                spinners[0].parentNode.removeChild(spinners[0]);
              }
              const finalLine = document.createElement('p');
              finalLine.style.fontWeight = 'bold';
              finalLine.textContent = (data.status === 'success' ? '‚úÖ ' : '‚ùå ') + data.message;
              resultDiv.appendChild(finalLine);
              resultDiv.className = data.status === 'success' ? 'success' : 'error';
              resultDiv.scrollTop = resultDiv.scrollHeight;
              submitButton.disabled = false;
              submitButton.textContent = 'ÂºÄÂßãÊâßË°å';

              if (data.error_code === '{{ SEAT_TAKEN_ERROR_CODE }}') {
                seatNumberInput.style.borderColor = 'red';
                seatNumberInput.focus();
                const seatTakenHint = document.createElement('p');
                seatTakenHint.classList.add('error-message'); // Use error style
                seatTakenHint.textContent = 'ÊèêÁ§∫ÔºöËØ•Â∫ß‰ΩçÂ∑≤Ë¢´Âç†Áî®ÔºåËØ∑ÈÄâÊã©ÂÖ∂‰ªñÂ∫ß‰ΩçÂêéÈáçËØï„ÄÇ';
                resultDiv.appendChild(seatTakenHint);
                resultDiv.scrollTop = resultDiv.scrollHeight;
              } else {
                seatNumberInput.style.borderColor = '';
              }
            }
          } catch (e) {
            console.error('Error parsing WebSocket message:', e);
            addResultMessage('Â§ÑÁêÜ WebSocket Ê∂àÊÅØÊó∂Âá∫Èîô: ' + event.data, 'error');
            resultDiv.className = 'error';
          }
        }; // End of onmessage

        websocket.onerror = (error) => {
          console.error('WebSocket Error:', error);
          wsConnectionAttempted = false; // Allow retry attempt
          // Don't add error message here, onclose will handle retry logic
        };

        websocket.onclose = (event) => {
          console.log('WebSocket Closed:', event.code, event.reason, `Manual disconnect: ${isManualDisconnect}`);
          wsReady = false;
          wsConnectionAttempted = false; // Allow new attempts

          // --- Reconnection Logic ---
          if (!isManualDisconnect) { // Only reconnect if not closed intentionally
            // Clear previous disconnected messages if any
            const disconnectedMessages = resultDiv.querySelectorAll('p.disconnected-message');
            disconnectedMessages.forEach(p => p.remove());

            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
              reconnectAttempts++;
              // Exponential backoff for retries (e.g., 1s, 2s, 4s, 8s, 16s)
              const delay = Math.pow(2, reconnectAttempts - 1) * 1000;
              console.log(`WebSocket disconnected. Attempting reconnect ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay / 1000}s...`);
              addResultMessage(`‚ùå Áä∂ÊÄÅÊõ¥Êñ∞ÈÄöÈÅìÂ∑≤Êñ≠ÂºÄ„ÄÇÊ≠£Âú®Â∞ùËØïÈáçÊñ∞ËøûÊé• (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`, 'disconnected');
              submitButton.disabled = true;
              submitButton.textContent = 'ÈáçÊñ∞ËøûÊé•‰∏≠...';

              // Clear previous timeout if exists and set new one
              if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId);
              reconnectTimeoutId = setTimeout(connectWebSocket, delay);

            } else {
              console.log(`WebSocket disconnected. Max reconnect attempts (${MAX_RECONNECT_ATTEMPTS}) reached. Giving up temporarily.`);
              addResultMessage(`‚ùå Áä∂ÊÄÅÊõ¥Êñ∞ÈÄöÈÅìÂ∑≤Êñ≠ÂºÄ„ÄÇÂ∑≤ËææÊúÄÂ§ßÈáçËøûÊ¨°Êï∞ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªúÊàñÊâãÂä®Âà∑Êñ∞„ÄÇ`, 'error');
              submitButton.disabled = true; // Keep disabled
              submitButton.textContent = 'ÈÄöÈÅìÊñ≠ÂºÄ';
              // Optional: Reset counter after a longer period?
              // setTimeout(() => { reconnectAttempts = 0; }, 60000); // Reset after 1 minute
            }
          } else {
            console.log("WebSocket closed intentionally, no reconnect needed.");
            // Optionally add a message indicating manual close if needed
            // addResultMessage('WebSocket Â∑≤ÂÖ≥Èó≠„ÄÇ', 'info');
          }
        }; // End of onclose

      } catch (e) {
        console.error("Failed to create WebSocket object:", e);
        wsConnectionAttempted = false; // Allow retry attempt
        addResultMessage('‚ùå ÂàõÂª∫ WebSocket ËøûÊé•Â§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÊµèËßàÂô®ÊîØÊåÅÊàñÁΩëÁªúËÆæÁΩÆ„ÄÇ', 'error');
        submitButton.textContent = 'ËøûÊé•Â§±Ë¥•';
        submitButton.disabled = true;
        // Optional: Add retry logic here too if desired
      }
    } // End of connectWebSocket function

    // --- Function to close WebSocket manually ---
    function disconnectWebSocket() {
      if (websocket) {
        console.log("Manually closing WebSocket connection.");
        isManualDisconnect = true; // Set flag *before* closing
        websocket.close();
      }
      // Clear any pending reconnect timeouts
      if (reconnectTimeoutId) {
        clearTimeout(reconnectTimeoutId);
        reconnectTimeoutId = null;
      }
      wsReady = false;
      wsConnectionAttempted = false; // Allow new connections later
      reconnectAttempts = 0; // Reset counter on manual disconnect
      // Optional: Update UI to reflect manual disconnect
      // submitButton.textContent = 'ÈÄöÈÅìÂ∑≤Êñ≠ÂºÄ';
      // submitButton.disabled = true;
    }

    // --- Listen for Page Visibility Changes ---
    document.addEventListener('visibilitychange', () => {
      if (document.visibilityState === 'visible') {
        console.log("Page became visible.");
        // If WebSocket is not connected or connecting, attempt to connect
        if (!websocket || (websocket.readyState !== WebSocket.OPEN && websocket.readyState !== WebSocket.CONNECTING)) {
          console.log("WebSocket not connected on visibility change, attempting to connect.");
          // Reset attempts slightly more aggressively when user comes back
          reconnectAttempts = 0;
          connectWebSocket();
        } else {
          console.log("WebSocket already connected or connecting.");
        }
      } else {
        console.log("Page became hidden.");
        // Optional: You could potentially send a 'pause' message to the server here if needed
        // Or just let the browser/OS handle suspension
      }
    });

    // --- Form Logic ---
    function updateWebForm() {
      /* Form update logic remains the same */
      const mode = modeSelect.value;
      seatLabel.textContent = 'Â∫ß‰ΩçÂè∑:';
      seatNumberInput.placeholder = '‰æãÂ¶Ç 127';
      if (mode === '1') { timeLabel.textContent = 'È¢ÑÁ∫¶ÊâßË°åÊó∂Èó¥ (‰ªäÊó•ÊôöÈó¥, ÂøÖÂ°´):'; timeInput.placeholder = 'HH:MM:SS (‰æãÂ¶Ç 21:48:00)'; timeHint.textContent = `ÈúÄÂú®ÊåáÂÆöÊó∂Èó¥Á™óÂè£ÂÜÖ ({{ TOMORROW_RESERVE_WINDOW_START_STR }} - {{ TOMORROW_RESERVE_WINDOW_END_STR }}).`; timeInput.required = true; }
      else { timeLabel.textContent = 'Êä¢Â∫ßÊâßË°åÊó∂Èó¥ (ÂèØÈÄâ, ÁïôÁ©∫ÂàôÁ´ãÂç≥ÊâßË°å):'; timeInput.placeholder = 'HH:MM:SS (‰æãÂ¶Ç 08:00:00)'; timeHint.textContent = 'Â¶ÇÊûúÊåáÂÆöÊó∂Èó¥ÔºåÂøÖÈ°ªÊòØÊú™Êù•ÁöÑÊó∂Èó¥„ÄÇ'; timeInput.required = false; }
      seatNumberInput.style.borderColor = '';
    }

    // --- Load Room Mappings ---
    async function loadRooms() {
      /* Loading logic remains largely the same */
      submitButton.disabled = true;
      submitButton.textContent = 'Âä†ËΩΩÊï∞ÊçÆ...';
      try {
        const response = await fetch('{{ mappings_url }}');
        if (!response.ok) { const errorText = await response.text(); throw new Error(`HTTP error! status: ${response.status}, details: ${errorText}`); }
        const data = await response.json();
        if (!data.rooms || Object.keys(data.rooms).length === 0) { throw new Error("ÊúçÂä°Âô®ËøîÂõûÁöÑÈòÖËßàÂÆ§ÂàóË°®‰∏∫Á©∫„ÄÇ"); }
        roomSelect.innerHTML = '<option value="" disabled selected>ËØ∑ÈÄâÊã©ÈòÖËßàÂÆ§</option>';
        for (const libId in data.rooms) { const option = document.createElement('option'); option.value = libId; option.textContent = data.rooms[libId]; roomSelect.appendChild(option); }
        // Attempt initial WebSocket connection AFTER loading rooms
        connectWebSocket();
      } catch (error) {
        console.error('Error loading room mappings:', error);
        resultDiv.innerHTML = '';
        addResultMessage(`‚ùå Âä†ËΩΩÈòÖËßàÂÆ§ÂàóË°®Â§±Ë¥•: ${error.message} ËØ∑Âà∑Êñ∞È°µÈù¢ÊàñÊ£ÄÊü•ÊúçÂä°Âô®Áä∂ÊÄÅ„ÄÇ`, 'error');
        resultDiv.className = 'error';
        submitButton.textContent = 'Âä†ËΩΩÂ§±Ë¥•';
        submitButton.disabled = true;
      }
    }

    // --- Form Submission ---
    seatForm.addEventListener('submit', async function (event) {
      /* Submission logic remains largely the same,
         but relies on connectWebSocket for connection check */
      event.preventDefault();
      seatNumberInput.style.borderColor = '';

      resultDiv.innerHTML = '';
      resultDiv.className = 'processing';
      addResultMessage('Ê≠£Âú®È™åËØÅÂπ∂Êèê‰∫§ËØ∑Ê±Ç...', 'info', true);
      submitButton.disabled = true;
      submitButton.textContent = 'Êèê‰∫§‰∏≠...';

      // Check WebSocket state *before* submitting
      if (!wsReady || !websocket || websocket.readyState !== WebSocket.OPEN) {
        resultDiv.innerHTML = ''; // Clear submitting message
        addResultMessage('‚ùå WebSocket Êú™ËøûÊé•ÊàñËøûÊé•‰∏≠Êñ≠„ÄÇËØ∑Á≠âÂæÖÈáçËøûÊàñÊâãÂä®Âà∑Êñ∞„ÄÇ', 'error');
        resultDiv.className = 'error';
        submitButton.textContent = 'ÈÄöÈÅìÊñ≠ÂºÄ'; // Keep button disabled
        connectWebSocket(); // Try to trigger connection again
        return;
      }

      const data = { /* Form data gathering remains the same */
        mode: parseInt(modeSelect.value), cookieStr: cookieInput.value.trim(), libId: parseInt(roomSelect.value), timeStr: timeInput.value.trim(), seatNumber: seatNumberInput.value.trim(), clientId: clientId
      };

      // Frontend validation remains the same
      let validationError = null;
      if (!data.cookieStr) validationError = 'Cookie ‰∏çËÉΩ‰∏∫Á©∫„ÄÇ';
      else if (isNaN(data.libId) || data.libId <= 0) validationError = 'ËØ∑ÈÄâÊã©‰∏Ä‰∏™ÊúâÊïàÁöÑÈòÖËßàÂÆ§„ÄÇ';
      else if (!data.seatNumber) validationError = 'Â∫ß‰ΩçÂè∑‰∏çËÉΩ‰∏∫Á©∫„ÄÇ';
      else if (data.mode === 1 && !data.timeStr) validationError = 'ÊòéÊó•È¢ÑÁ∫¶Ê®°ÂºèÂøÖÈ°ªÊåáÂÆöÊâßË°åÊó∂Èó¥ (HH:MM:SS)„ÄÇ';
      else if (data.timeStr && !/^\d{2}:\d{2}:\d{2}$/.test(data.timeStr)) validationError = 'Êó∂Èó¥Ê†ºÂºèÈîôËØØÔºåÂ∫î‰∏∫ HH:MM:SS„ÄÇ';
      if (validationError) {
        resultDiv.innerHTML = '';
        addResultMessage(`‚ùå ËæìÂÖ•ÈîôËØØ: ${validationError}`, 'error');
        resultDiv.className = 'error';
        submitButton.disabled = false; submitButton.textContent = 'ÂºÄÂßãÊâßË°å';
        return;
      }

      // Fetch API remains the same
      try {
        const response = await fetch('/api/submit_request', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data), });
        const responseData = await response.json();
        if (!response.ok) { const errorDetail = responseData.detail || `HTTP Error ${response.status}: ${response.statusText}`; throw new Error(errorDetail); }
        console.log("HTTP Submission successful, backend task queued:", responseData);
        submitButton.textContent = 'Â§ÑÁêÜ‰∏≠...'; // Keep button disabled, wait for WS messages
        submitButton.disabled = true;
      } catch (error) {
        console.error('Êèê‰∫§ËØ∑Ê±ÇÂ§±Ë¥•:', error);
        resultDiv.innerHTML = '';
        addResultMessage(`‚ùå Êèê‰∫§ËØ∑Ê±ÇÂ§±Ë¥•: ${error.message}`, 'error');
        resultDiv.className = 'error';
        submitButton.disabled = false;
        submitButton.textContent = 'ÂºÄÂßãÊâßË°å';
      }
    });

    // --- Initial Page Load ---
    updateWebForm();
    loadRooms(); // This will also trigger the first connectWebSocket attempt

  </script>
</body>

</html>