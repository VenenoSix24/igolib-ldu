<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æˆ‘å»æŠ¢ä¸ªåº§ - Webç‰ˆ</title>

  <!-- !!! æ·»åŠ  Toastify CSS !!! -->
  <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/toastify-js/src/toastify.min.css">

  <style>
    /* --- Base Variables (Light Mode) --- */
    :root {
      --bg-color: #f8f9fa;
      --text-color: #343a40;
      --heading-color: #212529;
      --label-color: #495057;
      --form-bg: #ffffff;
      --input-bg: #fff;
      --input-border: #ced4da;
      --input-focus-border: #86b7fe;
      --input-focus-shadow: rgba(13, 110, 253, 0.25);
      --button-bg: #0d6efd;
      --button-hover-bg: #0b5ed7;
      --button-active-bg: #0a58ca;
      --button-disabled-bg: #adb5bd;
      --button-text: white;
      --result-bg: #eef2f7;
      --result-border: #dee2e6;
      --result-text: #343a40;
      --spinner-color: #0d6efd;
      --link-color: #0d6efd;
      --small-text-color: #6c757d;
      --success-bg: #d1e7dd;
      --success-border: #198754;
      --success-text: #0f5132;
      --error-bg: #f8d7da;
      --error-border: #dc3545;
      --error-text: #842029;
      --info-bg: #cff4fc;
      --info-border: #0dcaf0;
      --info-text: #055160;
      --processing-bg: #fff3cd;
      /* Use info bg for processing message bg */
      --processing-border: #ffc107;
      --processing-text: #664d03;
      /* Use info text for processing message text */
      --shadow-color: rgba(0, 0, 0, 0.08);
      --auto-get-button-bg: #ffc107;
      /* Yellow */
      --auto-get-button-text: #343a40;
      /* Dark text on yellow */
      --auto-get-button-hover-bg: #e0a800;
      /* Darker yellow */
      --cookie-highlight-bg: #d1e7dd;
      /* Light green for success highlight */
    }

    /* --- Dark Mode Overrides --- */
    @media (prefers-color-scheme: dark) {
      :root {
        --bg-color: #1a1a1a;
        /* Even darker background */
        --text-color: #e0e0e0;
        --heading-color: #f8f9fa;
        --label-color: #adb5bd;
        --form-bg: #2c2c2c;
        /* Dark form background */
        --input-bg: #3a3a3a;
        --input-border: #555;
        --input-focus-border: #4a90e2;
        --input-focus-shadow: rgba(74, 144, 226, 0.3);
        --button-bg: #2a71d8;
        /* Adjusted blue */
        --button-hover-bg: #3b82f6;
        --button-active-bg: #1d4ed8;
        --button-disabled-bg: #555;
        --result-bg: #2c2c2c;
        --result-border: #555;
        --result-text: #e0e0e0;
        --spinner-color: #4a90e2;
        --link-color: #60a5fa;
        --small-text-color: #9ca3af;
        --success-bg: #113b21;
        /* Darker success */
        --success-border: #2f6f40;
        --success-text: #a7f3d0;
        /* Lighter green */
        --error-bg: #4a2327;
        --error-border: #fca5a5;
        /* Lighter red border */
        --error-text: #fecaca;
        /* Lighter red */
        --info-bg: #1c3a47;
        --info-border: #38bdf8;
        /* Lighter cyan border */
        --info-text: #a5f3fc;
        /* Lighter cyan */
        --processing-bg: #1c3a47;
        /* Use info bg */
        --processing-border: #fbbf24;
        /* Lighter yellow border */
        --processing-text: #a5f3fc;
        /* Use info text */
        --shadow-color: rgba(255, 255, 255, 0.05);
        --auto-get-button-bg: #b8860b;
        --auto-get-button-text: #ffffff;
        --auto-get-button-hover-bg: #daa520;
        --cookie-highlight-bg: #113b21;
        /* Dark green for success highlight */
      }

      /* Specific override for select arrow in dark mode */
      select {
        background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23e0e0e0' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
      }

      input::placeholder {
        color: #777;
      }

      /* Hide scrollbar track in dark mode for Webkit */
      ::-webkit-scrollbar-track {
        background: var(--form-bg);
      }

      ::-webkit-scrollbar-thumb {
        background-color: #555;
      }

      ::-webkit-scrollbar-thumb:hover {
        background-color: #777;
      }
    }

    /* Global Reset & Box Sizing */
    *,
    *::before,
    *::after {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    /* Hide scrollbar for Webkit browsers (Chrome, Safari, Edge) */
    body::-webkit-scrollbar {
      display: none;
    }

    #result::-webkit-scrollbar {
      display: none;
    }

    /* Hide scrollbar for Firefox */
    body {
      scrollbar-width: none;
      /* Firefox */
    }

    #result {
      scrollbar-width: none;
      /* Firefox */
    }

    /* Hide scrollbar for IE/Edge (older versions) */
    body {
      -ms-overflow-style: none;
      /* IE and Edge */
    }

    #result {
      -ms-overflow-style: none;
      /* IE and Edge */
    }


    /* Body Styling */
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
      line-height: 1.6;
      padding: 20px;
      max-width: 700px;
      margin: 30px auto;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }

    /* Headings */
    h1,
    h2 {
      color: var(--heading-color);
      text-align: center;
      margin-bottom: 1.5rem;
    }

    h1 {
      font-size: 1.8rem;
      font-weight: 600;
    }

    h2 {
      font-size: 1.3rem;
      font-weight: 500;
      margin-top: 2.5rem;
    }

    /* Form Styling */
    form {
      background-color: var(--form-bg);
      padding: 30px 35px;
      border-radius: 12px;
      box-shadow: 0 6px 20px var(--shadow-color);
      border: 1px solid var(--input-border);
      transition: background-color 0.3s, border-color 0.3s;
    }

    /* Labels */
    label {
      display: block;
      margin-top: 1.2rem;
      margin-bottom: 0.5rem;
      font-weight: 500;
      color: var(--label-color);
      font-size: 0.95rem;
    }

    /* Input Fields & Select */
    input[type=text],
    input[type=number],
    select {
      width: 100%;
      padding: 12px 15px;
      margin-top: 5px;
      border: 1px solid var(--input-border);
      border-radius: 6px;
      font-size: 1rem;
      color: var(--text-color);
      background-color: var(--input-bg);
      transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out, background-color 0.3s, color 0.3s;
    }

    /* Select Specific Styling */
    select {
      appearance: none;
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 16 16'%3e%3cpath fill='none' stroke='%23343a40' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M2 5l6 6 6-6'/%3e%3c/svg%3e");
      background-repeat: no-repeat;
      background-position: right 0.75rem center;
      background-size: 16px 12px;
      padding-right: 2.5rem;
    }

    /* Focus State */
    input:focus,
    select:focus {
      border-color: var(--input-focus-border);
      outline: 0;
      box-shadow: 0 0 0 0.25rem var(--input-focus-shadow);
    }

    /* Placeholders */
    input::placeholder {
      color: #adb5bd;
      opacity: 1;
    }

    /* Button Styling */
    button {
      display: block;
      width: 100%;
      padding: 12px 25px;
      cursor: pointer;
      background-color: var(--button-bg);
      color: var(--button-text);
      border: none;
      border-radius: 6px;
      font-size: 1.1rem;
      font-weight: 500;
      transition: background-color 0.2s ease, transform 0.1s ease;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
    }

    button:hover:not(:disabled) {
      background-color: var(--button-hover-bg);
      transform: translateY(-1px);
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
    }

    button:active:not(:disabled) {
      background-color: var(--button-active-bg);
      transform: translateY(0px);
    }

    button:disabled {
      background-color: var(--button-disabled-bg);
      cursor: not-allowed;
      opacity: 0.7;
      box-shadow: none;
    }

    /* Specific button styles */
    #autoCookieBtn {
      background-color: var(--auto-get-button-bg);
      color: var(--auto-get-button-text);
      margin-top: 15px;
      margin-bottom: 5px;
    }

    #autoCookieBtn:hover:not(:disabled) {
      background-color: var(--auto-get-button-hover-bg);
    }

    #submitBtn {
      margin-top: 30px;
    }

    /* Result Area Styling */
    #result {
      margin-top: 25px;
      padding: 15px 20px;
      border: 1px solid var(--result-border);
      min-height: 100px;
      max-height: 400px;
      /* Keep max-height */
      overflow-y: auto;
      /* Keep auto scroll if you might revert hiding */
      background-color: var(--result-bg);
      color: var(--result-text);
      border-radius: 8px;
      font-family: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace;
      font-size: 0.9rem;
      line-height: 1.5;
      word-wrap: break-word;
      transition: border-color 0.3s ease, background-color 0.3s;
    }

    #result p {
      margin: 5px 0;
      padding: 5px 8px;
      border-radius: 4px;
      white-space: pre-wrap;
      display: flex;
      align-items: flex-start;
    }

    /* State styling */
    #result.success {
      border-color: var(--success-border);
    }

    #result.error {
      border-color: var(--error-border);
    }

    #result.info {
      border-color: var(--info-border);
    }

    #result.processing {
      border-color: var(--processing-border);
    }

    /* Specific message type styling */
    #result p.error-message,
    #result.error p:last-child {
      color: var(--error-text);
      background-color: var(--error-bg);
      border-left: 4px solid var(--error-border);
      padding-left: 12px;
    }

    #result p.success-message,
    #result.success p:last-child {
      color: var(--success-text);
      background-color: var(--success-bg);
      border-left: 4px solid var(--success-border);
      padding-left: 12px;
    }

    #result p.disconnected-message {
      color: var(--small-text-color);
      font-style: italic;
      background-color: transparent;
      border-left: none;
      padding-left: 8px;
    }

    #result p.info-message {
      color: var(--info-text);
      background-color: var(--info-bg);
      border-left: 4px solid var(--info-border);
      padding-left: 12px;
    }

    /* Highlight cookie success */
    #result p.success-message:containing('Cookie å·²æˆåŠŸè·å–å¹¶å¡«å……ï¼') {
      font-weight: bold;
    }

    /* Example using pseudo-selector (might not work in all browsers) */

    /* Spinner Styling */
    .spinner {
      border: 3px solid rgba(0, 0, 0, 0.1);
      width: 1em;
      height: 1em;
      border-radius: 50%;
      border-left-color: var(--spinner-color);
      margin-right: 10px;
      display: inline-block;
      vertical-align: -0.125em;
      flex-shrink: 0;
      animation: spin 1s linear infinite;
      margin-top: 0.1em;
    }

    @keyframes spin {
      0% {
        transform: rotate(0deg);
      }

      100% {
        transform: rotate(360deg);
      }
    }

    /* Small Text Hint */
    small {
      color: var(--small-text-color);
      display: block;
      margin-top: 5px;
      font-size: 0.875em;
      line-height: 1.4;
    }

    /* --- Styles for Time Selection Section --- */
    #timeSelectionSection {
      margin-top: 1.2rem; /* Replaces label's top margin */
    }

    #time_label_main {
       display: block; /* Ensure it takes full width like other labels */
       margin-bottom: 0.5rem; /* Consistent bottom margin */
       font-weight: 500; /* Consistent font weight */
       color: var(--label-color);
       font-size: 0.95rem;
    }

    #mode1TimeOptions,
    #mode2TimeInput {
      margin-top: 5px; /* Spacing below the main label */
    }

    /* Initially hide mode 1 options, JS will control this */
    #mode1TimeOptions {
        display: none;
    }

    #mode1TimeOptions > div { /* Style direct children divs for spacing */
       margin-bottom: 8px;
    }
    #mode1TimeOptions > div:last-child { /* Remove margin from last element in group */
        margin-bottom: 0;
    }


    /* Style labels associated with radio buttons */
    #mode1TimeOptions label[for^="timeOption"] {
      font-weight: normal; /* Override default label weight */
      display: inline; /* Allow label next to radio */
      margin-top: 0; /* Override default label margin */
      margin-bottom: 0;
      font-size: 1rem; /* Match input font size */
      color: var(--text-color); /* Use standard text color */
    }

    #customTimeDiv {
      display: none; /* Initially hidden, JS controls this */
      margin-left: 25px; /* Indent the custom input */
      margin-top: 5px;
    }

    /* Style the hints within time sections */
    #time_hint_mode1 {
       display: block; /* Ensure hint takes full width */
       margin-left: 5px;
       margin-top: 8px;
       /* Use the standard small text style */
       color: var(--small-text-color);
       font-size: 0.875em;
       line-height: 1.4;
    }

     #time_hint_mode2 {
       display: block; /* Ensure hint takes full width */
       /* Use the standard small text style */
       color: var(--small-text-color);
       font-size: 0.875em;
       line-height: 1.4;
       margin-top: 5px; /* Add margin like other small hints */
    }

    /* Ensure radio buttons align better with text */
    input[type="radio"] {
        vertical-align: middle;
        margin-right: 4px;
    }

  </style>

  <!-- !!! æ·»åŠ  Toastify JS !!! -->
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/toastify-js"></script>

</head>

<body>
  <h1>æˆ‘å»æŠ¢ä¸ªåº§ v2.1.1 ğŸ“š</h1>
  <form id="seatForm">
    <label for="mode">æ“ä½œæ¨¡å¼:</label>
    <select id="mode" name="mode" required onchange="updateWebForm()">
      <option value="1">æ˜æ—¥é¢„çº¦ ({{ TOMORROW_RESERVE_WINDOW_START_STR }} - {{ TOMORROW_RESERVE_WINDOW_END_STR }})</option>
      <option value="2" selected>ç«‹å³æŠ¢åº§ (å½“å‰æ—¶é—´)</option>
    </select>

    <button type="button" id="autoCookieBtn">è‡ªåŠ¨è·å– Cookie (éœ€é…åˆç”µè„‘æ“ä½œ >å®éªŒæ€§<)</button>

    <label for="cookieStr">Cookie (å¯æ‰‹åŠ¨è¾“å…¥æˆ–è‡ªåŠ¨è·å–):</label>
    <input type="text" id="cookieStr" name="cookieStr" required placeholder="åœ¨æ­¤ç²˜è´´ Cookie æˆ–ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®è‡ªåŠ¨è·å–">


    <label for="libId">é˜…è§ˆå®¤:</label>
    <select id="libId" name="libId" required>
      <option value="" disabled selected>æ­£åœ¨åŠ è½½é˜…è§ˆå®¤...</option>
    </select>

    <!-- <label for="timeStr" id="time_label">æŠ¢åº§æ‰§è¡Œæ—¶é—´ (ç•™ç©ºåˆ™ç«‹å³æ‰§è¡Œ):</label>
    <input type="text" id="timeStr" name="timeStr" pattern="\d{2}:\d{2}:\d{2}" placeholder="HH:MM:SS">
    <small id="time_hint">é¢„çº¦æ¨¡å¼éœ€åœ¨æŒ‡å®šæ—¶é—´çª—å£å†…ã€‚</small> -->
  
  <!-- æ—¶é—´é€‰æ‹©åŒºåŸŸ -->
  <div id="timeSelectionSection">
    <label id="time_label_main">æŠ¢åº§æ‰§è¡Œæ—¶é—´:</label> <!-- ä¸»æ ‡ç­¾ (æ ·å¼ç”±CSSæ§åˆ¶) -->
  
    <!-- æ¨¡å¼ 1: æ˜æ—¥é¢„çº¦çš„æ—¶é—´é€‰é¡¹ (display ç”± JS æ§åˆ¶) -->
    <div id="mode1TimeOptions">
      <div>
        <input type="radio" id="timeOptionDefault" name="timeOption" value="default" checked onchange="updateWebForm()">
        <label for="timeOptionDefault"> ä½¿ç”¨é»˜è®¤æ—¶é—´ (21:48:00)</label> <!-- ç§»é™¤å†…è”æ ·å¼ -->
      </div>
      <div>
        <input type="radio" id="timeOptionCustom" name="timeOption" value="custom" onchange="updateWebForm()">
        <label for="timeOptionCustom"> è‡ªå®šä¹‰æ—¶é—´:</label> <!-- ç§»é™¤å†…è”æ ·å¼ -->
      </div>
      <!-- è‡ªå®šä¹‰æ—¶é—´è¾“å…¥æ¡† (display å’Œ margin ç”± CSS/JS æ§åˆ¶) -->
      <div id="customTimeDiv">
        <input type="text" id="timeStr" name="timeStr" pattern="\d{2}:\d{2}:\d{2}" placeholder="HH:MM:SS">
      </div>
      <small id="time_hint_mode1">éœ€åœ¨æŒ‡å®šæ—¶é—´çª—å£å†… ({{ TOMORROW_RESERVE_WINDOW_START_STR }} - {{ TOMORROW_RESERVE_WINDOW_END_STR
        }})ã€‚</small> <!-- ç§»é™¤å†…è”æ ·å¼ -->
    </div>
  
    <!-- æ¨¡å¼ 2: ç«‹å³æŠ¢åº§çš„æ—¶é—´è¾“å…¥ (display ç”± JS æ§åˆ¶) -->
    <div id="mode2TimeInput">
      <input type="text" id="timeStrMode2" name="timeStrMode2" pattern="\d{2}:\d{2}:\d{2}" placeholder="HH:MM:SS (ç•™ç©ºåˆ™ç«‹å³)">
      <small id="time_hint_mode2">å¦‚æœæŒ‡å®šæ—¶é—´ï¼Œå¿…é¡»æ˜¯æœªæ¥çš„æ—¶é—´ã€‚</small> <!-- ç§»é™¤å†…è”æ ·å¼ -->
    </div>
  </div>

    <label for="seatNumber" id="seat_label">åº§ä½å·:</label>
    <input type="text" id="seatNumber" name="seatNumber" required placeholder="ä¾‹å¦‚ 127">

    <button type="submit" id="submitBtn" disabled>è¿æ¥ä¸­...</button>
  </form>

  <h2>æ“ä½œçŠ¶æ€ä¸ç»“æœ:</h2>
  <div id="result" class="info">ç­‰å¾…è¿æ¥çŠ¶æ€æ›´æ–°é€šé“...</div>

  <script>
    // --- Get DOM Elements ---
    const modeSelect = document.getElementById('mode');
    const cookieInput = document.getElementById('cookieStr');
    const roomSelect = document.getElementById('libId');
    const timeLabel = document.getElementById('time_label');
    const timeInput = document.getElementById('timeStr');
    const timeHint = document.getElementById('time_hint');
    const seatLabel = document.getElementById('seat_label');
    const seatNumberInput = document.getElementById('seatNumber');
    const seatForm = document.getElementById('seatForm');
    const resultDiv = document.getElementById('result');
    const submitButton = document.getElementById('submitBtn');
    const autoCookieButton = document.getElementById('autoCookieBtn');

    let websocket = null;
    const clientId = 'client_' + Date.now() + '_' + Math.random().toString(36).substring(2, 9);
    let wsReady = false;
    let wsConnectionAttempted = false;
    let reconnectAttempts = 0;
    const MAX_RECONNECT_ATTEMPTS = 5;
    let reconnectTimeoutId = null;
    let isManualDisconnect = false;
    let isCookieAcquisitionComplete = false;

    // --- Helper function to add messages ---
    function addResultMessage(message, type = 'info', includeSpinner = false) {
      const line = document.createElement('p');
      if (type === 'error') line.classList.add('error-message');
      else if (type === 'disconnected') line.classList.add('disconnected-message');
      else if (type === 'success') line.classList.add('success-message');
      else if (type === 'info') line.classList.add('info-message');
      if (includeSpinner && type !== 'disconnected' && type !== 'error' && type !== 'success') {
        const spinnerDiv = document.createElement('div'); spinnerDiv.className = 'spinner'; line.appendChild(spinnerDiv);
      }
      line.appendChild(document.createTextNode(message));
      resultDiv.appendChild(line);
      resultDiv.scrollTop = resultDiv.scrollHeight;
    }

    // --- WebSocket Setup with Reconnect Logic ---
    function connectWebSocket() {
      if (wsConnectionAttempted) return;
      wsConnectionAttempted = true; isManualDisconnect = false;
      const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
      const wsUrl = `${wsProtocol}//${window.location.host}/ws/${clientId}`;
      console.log(`Attempting WS connection (Attempt ${reconnectAttempts + 1})...`, wsUrl);
      if (reconnectAttempts === 0 && resultDiv.textContent.includes('ç­‰å¾…è¿æ¥')) resultDiv.innerHTML = '';
      if (!resultDiv.querySelector('p:last-child')?.textContent.includes('æ­£åœ¨è¿æ¥')) addResultMessage('æ­£åœ¨è¿æ¥çŠ¶æ€æ›´æ–°é€šé“...', 'info', true);
      resultDiv.className = 'info'; submitButton.textContent = 'è¿æ¥ä¸­...'; submitButton.disabled = true; autoCookieButton.disabled = true;
      if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId); reconnectTimeoutId = null;
      try {
        websocket = new WebSocket(wsUrl);
        websocket.onopen = () => {
          console.log('WS Connected'); wsReady = true; wsConnectionAttempted = false; reconnectAttempts = 0;
          const statusMessages = resultDiv.querySelectorAll('p'); statusMessages.forEach(p => { if (p.textContent.includes('æ­£åœ¨è¿æ¥') || p.textContent.includes('å·²æ–­å¼€')) p.remove(); });
          addResultMessage('âœ… é€šé“å·²è¿æ¥ã€‚', 'info'); resultDiv.className = 'info';
          if (!resultDiv.classList.contains('processing')) { submitButton.textContent = 'å¼€å§‹æ‰§è¡Œ'; submitButton.disabled = false; autoCookieButton.disabled = false; }
        };
        websocket.onmessage = (event) => {
          console.log('WS Message:', event.data); wsConnectionAttempted = false;
          try {
            const data = JSON.parse(event.data);
            if (data.type === 'status') {
              addResultMessage(data.message, 'info', true); resultDiv.className = 'processing';
              if (submitButton.textContent.includes('è·å–Cookieä¸­') || submitButton.textContent.includes('æäº¤ä¸­') || submitButton.textContent.includes('å¤„ç†ä¸­')) { submitButton.disabled = true; autoCookieButton.disabled = true; }
            } else if (data.type === 'result') {
              const spinners = resultDiv.getElementsByClassName('spinner'); while (spinners.length > 0) spinners[0].parentNode.removeChild(spinners[0]);
              const finalLine = document.createElement('p'); finalLine.style.fontWeight = 'bold'; finalLine.textContent = (data.status === 'success' ? 'âœ… ' : 'âŒ ') + data.message; resultDiv.appendChild(finalLine); resultDiv.className = data.status === 'success' ? 'success' : 'error'; resultDiv.scrollTop = resultDiv.scrollHeight;
              submitButton.disabled = false; autoCookieButton.disabled = false; submitButton.textContent = 'å¼€å§‹æ‰§è¡Œ'; // Re-enable after result
              if (data.error_code === '{{ SEAT_TAKEN_ERROR_CODE }}') {
                seatNumberInput.style.borderColor = 'var(--error-border)'; seatNumberInput.focus();
                addResultMessage('æç¤ºï¼šè¯¥åº§ä½å·²è¢«å ç”¨ï¼Œè¯·é€‰æ‹©å…¶ä»–åº§ä½åé‡è¯•ã€‚', 'error');
                resultDiv.scrollTop = resultDiv.scrollHeight;
              } else { seatNumberInput.style.borderColor = ''; seatNumberInput.style.boxShadow = ''; }
              // --- !!! 2. æ·»åŠ  Result Toast é€šçŸ¥ !!! ---
              const toastDuration = data.status === 'success' ? 5000 : 8000; // æˆåŠŸçŸ­ä¸€ç‚¹ï¼Œå¤±è´¥é•¿ä¸€ç‚¹
              const toastText = (data.status === 'success' ? 'âœ… æ“ä½œæˆåŠŸ' : 'âŒ æ“ä½œå¤±è´¥') + (data.message.length < 50 ? `: ${data.message}` : ''); // å¦‚æœæ¶ˆæ¯çŸ­å°±é™„åŠ ä¸Š
              const toastStyle = data.status === 'success' ?
                { background: "var(--success-bg)", color: "var(--success-text)", borderLeft: "5px solid var(--success-border)" } :
                { background: "var(--error-bg)", color: "var(--error-text)", borderLeft: "5px solid var(--error-border)" };

              Toastify({
                text: toastText,
                duration: toastDuration,
                close: false, // æ— å…³é—­æŒ‰é’®
                gravity: "top", // é¡¶éƒ¨æ˜¾ç¤º
                position: "right", // å³ä¸Šè§’
                stopOnFocus: true,
                style: {
                  ...toastStyle, // åº”ç”¨æˆåŠŸæˆ–å¤±è´¥çš„æ ·å¼
                  borderRadius: "8px",
                  boxShadow: "0 3px 6px rgba(0,0,0,0.16)"
                }
              }).showToast();
            } else if (data.type === 'cookie_update') {
              console.log("Received cookie update:", data.cookie); cookieInput.value = data.cookie;
              cookieInput.style.backgroundColor = 'var(--cookie-highlight-bg)'; setTimeout(() => { cookieInput.style.backgroundColor = ''; }, 1500);
              const spinners = resultDiv.getElementsByClassName('spinner'); while (spinners.length > 0) spinners[0].parentNode.removeChild(spinners[0]);
              const waitingMessages = resultDiv.querySelectorAll('p'); waitingMessages.forEach(p => { if (p.textContent.includes('ç›‘æ§') || p.textContent.includes('ç­‰å¾…')) p.remove(); });
              addResultMessage('âœ… Cookie å·²æˆåŠŸè·å–å¹¶å¡«å……ï¼', 'success'); resultDiv.className = 'success';
              submitButton.disabled = false; autoCookieButton.disabled = false; submitButton.textContent = 'å¼€å§‹æ‰§è¡Œ'; // Re-enable after cookie update

              // --- !!! ä½¿ç”¨ Toastify æç¤ºå–æ¶ˆä»£ç† !!! ---
              Toastify({
                text: "âœ… Cookie å·²è·å–ï¼\nè¯·è¿è¡Œ unset_proxy.bat å…³é—­ä»£ç†",
                duration: 8000,
                close: false,
                gravity: "top",
                position: "right", // æ”¹ä¸ºå³ä¸Šè§’
                stopOnFocus: true,
                style: {
                  background: "var(--success-bg)", // ä½¿ç”¨ Success èƒŒæ™¯è‰²
                  color: "var(--success-text)", // ä½¿ç”¨ Success æ–‡æœ¬è‰²
                  borderRadius: "8px",
                  boxShadow: "0 3px 6px rgba(0,0,0,0.16)",
                  borderLeft: "5px solid var(--success-border)" // å·¦ä¾§é¢œè‰²æ¡
                }
              }).showToast();

            }
          } catch (e) { console.error('Error parsing WS message:', e); addResultMessage('å¤„ç† WebSocket æ¶ˆæ¯å‡ºé”™: ' + event.data, 'error'); resultDiv.className = 'error'; }
        };
        websocket.onerror = (error) => { console.error('WS Error:', error); wsConnectionAttempted = false; };
        websocket.onclose = (event) => {
          console.log('WS Closed:', event.code, event.reason, `Manual: ${isManualDisconnect}`); wsReady = false; wsConnectionAttempted = false;
          if (!isManualDisconnect) {
            const statusMessages = resultDiv.querySelectorAll('p'); statusMessages.forEach(p => { if (p.textContent.includes('å·²æ–­å¼€') || p.textContent.includes('æ­£åœ¨è¿æ¥')) p.remove(); });
            if (reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
              reconnectAttempts++; const delay = Math.pow(2, reconnectAttempts - 1) * 1000;
              console.log(`WS Reconnect attempt ${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS} in ${delay / 1000}s`);
              addResultMessage(`ğŸ”Œ é€šé“å·²æ–­å¼€ã€‚å°è¯•é‡è¿ (${reconnectAttempts}/${MAX_RECONNECT_ATTEMPTS})...`, 'disconnected');
              submitButton.disabled = true; autoCookieButton.disabled = true; submitButton.textContent = 'é‡æ–°è¿æ¥ä¸­...'; resultDiv.className = 'error';
              if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId); reconnectTimeoutId = setTimeout(connectWebSocket, delay);
            } else {
              console.log(`WS Max reconnect attempts reached.`);
              addResultMessage(`âŒ é€šé“è¿æ¥å¤±è´¥ã€‚å·²è¾¾æœ€å¤§é‡è¿æ¬¡æ•°ï¼Œè¯·åˆ·æ–°é¡µé¢ã€‚`, 'error');
              submitButton.disabled = true; autoCookieButton.disabled = true; submitButton.textContent = 'è¿æ¥å¤±è´¥'; resultDiv.className = 'error';
            }
          } else console.log("WS closed intentionally.");
        };
      } catch (e) { console.error("Failed to create WebSocket:", e); wsConnectionAttempted = false; resultDiv.innerHTML = ''; addResultMessage('âŒ åˆ›å»º WebSocket å¤±è´¥ã€‚', 'error'); resultDiv.className = 'error'; submitButton.textContent = 'è¿æ¥å¤±è´¥'; submitButton.disabled = true; autoCookieButton.disabled = true; }
    }
    function disconnectWebSocket() { if (websocket) { console.log("Manually closing WS."); isManualDisconnect = true; websocket.close(); } if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId); reconnectTimeoutId = null; wsReady = false; wsConnectionAttempted = false; reconnectAttempts = 0; }
    document.addEventListener('visibilitychange', () => { if (document.visibilityState === 'visible') { console.log("Page visible."); if (!websocket || (websocket.readyState !== WebSocket.OPEN && websocket.readyState !== WebSocket.CONNECTING)) { console.log("WS reconnect on visibility."); reconnectAttempts = 0; if (reconnectTimeoutId) clearTimeout(reconnectTimeoutId); connectWebSocket(); } else console.log("WS connected on visibility."); } else console.log("Page hidden."); });

    // --- Form Logic ---
    function updateWebForm() {
      const mode = modeSelect.value;
      const timeLabelMain = document.getElementById('time_label_main');
      const mode1OptionsDiv = document.getElementById('mode1TimeOptions');
      const mode2InputDiv = document.getElementById('mode2TimeInput');
      const customTimeDiv = document.getElementById('customTimeDiv');
      const timeInputCustom = document.getElementById('timeStr'); // è‡ªå®šä¹‰æ—¶é—´è¾“å…¥æ¡†
      const timeInputMode2 = document.getElementById('timeStrMode2'); // æ¨¡å¼2æ—¶é—´è¾“å…¥æ¡†
      const timeOptionDefault = document.getElementById('timeOptionDefault');
      const timeOptionCustom = document.getElementById('timeOptionCustom');
      const timeHintMode1 = document.getElementById('time_hint_mode1');
      const timeHintMode2 = document.getElementById('time_hint_mode2');

      seatLabel.textContent = 'åº§ä½å·:'; seatNumberInput.placeholder = 'ä¾‹å¦‚ 127';

      if (mode === '1') { // æ˜æ—¥é¢„çº¦æ¨¡å¼
        timeLabelMain.textContent = 'é¢„çº¦æ‰§è¡Œæ—¶é—´:'; // æ›´æ–°ä¸»æ ‡ç­¾
        mode1OptionsDiv.style.display = 'block'; // æ˜¾ç¤ºæ¨¡å¼1çš„é€‰é¡¹
        mode2InputDiv.style.display = 'none';   // éšè—æ¨¡å¼2çš„è¾“å…¥
        timeHintMode1.style.display = 'block';  // æ˜¾ç¤ºæ¨¡å¼1æç¤º

        // æ ¹æ®é€‰ä¸­çš„å•é€‰æŒ‰é’®å†³å®šæ˜¯å¦æ˜¾ç¤ºè‡ªå®šä¹‰è¾“å…¥æ¡†å’Œè®¾ç½®å¿…å¡«
        if (timeOptionCustom.checked) {
          customTimeDiv.style.display = 'block';
          timeInputCustom.required = true; // è‡ªå®šä¹‰æ—¶é—´å¿…å¡«
          timeInputMode2.required = false; // æ¨¡å¼2è¾“å…¥æ¡†æ°¸ä¸ä¸ºå¿…å¡«
        } else { // é»˜è®¤æ—¶é—´è¢«é€‰ä¸­
          customTimeDiv.style.display = 'none';
          timeInputCustom.required = false; // é»˜è®¤æ—¶é—´æ— éœ€è¾“å…¥ï¼Œæ‰€ä»¥ä¸å¿…å¡«
          timeInputMode2.required = false;
        }

      } else { // æ¨¡å¼ 2: ç«‹å³æŠ¢åº§æ¨¡å¼
        timeLabelMain.textContent = 'æŠ¢åº§æ‰§è¡Œæ—¶é—´ (å¯é€‰):'; // æ›´æ–°ä¸»æ ‡ç­¾
        mode1OptionsDiv.style.display = 'none'; // éšè—æ¨¡å¼1çš„é€‰é¡¹
        mode2InputDiv.style.display = 'block';  // æ˜¾ç¤ºæ¨¡å¼2çš„è¾“å…¥
        timeHintMode2.style.display = 'block';  // æ˜¾ç¤ºæ¨¡å¼2æç¤º

        timeInputCustom.required = false; // è‡ªå®šä¹‰æ—¶é—´è¾“å…¥æ¡†åœ¨æ¨¡å¼2ä¸‹ä¸å¿…å¡«
        timeInputMode2.required = false; // æ¨¡å¼2çš„æ—¶é—´æ˜¯å¯é€‰çš„
      }

      // æ¸…é™¤åº§ä½å·çš„é”™è¯¯æ ·å¼ (è¿™éƒ¨åˆ†ä¿ç•™)
      seatNumberInput.style.borderColor = '';
      seatNumberInput.style.boxShadow = '';
    }
    // --- Load Room Mappings ---
    async function loadRooms() {
      submitButton.disabled = true; submitButton.textContent = 'åŠ è½½æ•°æ®...'; autoCookieButton.disabled = true; roomSelect.innerHTML = '<option value="" disabled selected>æ­£åœ¨åŠ è½½é˜…è§ˆå®¤...</option>';
      try {
        const response = await fetch('{{ mappings_url }}');
        if (!response.ok) { const errorText = await response.text(); throw new Error(`HTTP ${response.status}: ${errorText || 'æœåŠ¡å™¨é”™è¯¯'}`); }
        const data = await response.json();
        if (!data.rooms || typeof data.rooms !== 'object' || Object.keys(data.rooms).length === 0) throw new Error("é˜…è§ˆå®¤åˆ—è¡¨ä¸ºç©ºæˆ–æ ¼å¼é”™è¯¯ã€‚");
        roomSelect.innerHTML = '<option value="" disabled selected>è¯·é€‰æ‹©é˜…è§ˆå®¤</option>';
        for (const libId in data.rooms) { const option = document.createElement('option'); option.value = libId; option.textContent = data.rooms[libId]; roomSelect.appendChild(option); }
        connectWebSocket();
      } catch (error) { console.error('Error loading rooms:', error); resultDiv.innerHTML = ''; addResultMessage(`âŒ åŠ è½½é˜…è§ˆå®¤å¤±è´¥: ${error.message} è¯·åˆ·æ–°ã€‚`, 'error'); resultDiv.className = 'error'; submitButton.textContent = 'åŠ è½½å¤±è´¥'; submitButton.disabled = true; autoCookieButton.disabled = true; roomSelect.innerHTML = '<option value="" disabled selected>åŠ è½½å¤±è´¥</option>'; }
    }

    // --- Auto Cookie Button Listener ---
    autoCookieButton.addEventListener('click', async () => {
      if (!wsReady || !websocket || websocket.readyState !== WebSocket.OPEN) { addResultMessage('âŒ WebSocket æœªè¿æ¥ï¼Œæ— æ³•å¼€å§‹ã€‚', 'error'); resultDiv.className = 'error'; connectWebSocket(); return; }
      resultDiv.innerHTML = ''; addResultMessage('æ­£åœ¨è¯·æ±‚å¯åŠ¨ Cookie ç›‘æ§...', 'info', true); resultDiv.className = 'processing';
      submitButton.disabled = true; autoCookieButton.disabled = true; submitButton.textContent = 'è·å–Cookieä¸­...'; // Specific text
      try {
        const response = await fetch(`/api/start_auto_cookie_watch/${clientId}`, { method: 'POST' });
        const data = await response.json();
        if (!response.ok) throw new Error(data.detail || `HTTP Error ${response.status}`);
        console.log("Cookie watch started:", data.message); // Wait for WS instructions

         // --- !!! ä½¿ç”¨ Toastify æç¤ºè®¾ç½®ä»£ç† !!! ---
        Toastify({
          text: "âš™ï¸ è¯·è¿è¡Œ set_proxy.bat å¼€å¯ä»£ç†ï¼Œå¹¶æ“ä½œå¾®ä¿¡",
          duration: 7000,
          close: false,
          gravity: "top",
          position: "right", // æ”¹ä¸ºå³ä¸Šè§’
          stopOnFocus: true,
          style: {
            background: "var(--info-bg)", // ä½¿ç”¨ Info èƒŒæ™¯è‰²
            color: "var(--info-text)", // ä½¿ç”¨ Info æ–‡æœ¬è‰²
            borderRadius: "8px", // æ·»åŠ åœ†è§’
            boxShadow: "0 3px 6px rgba(0,0,0,0.16)", // æ·»åŠ ç»†å¾®é˜´å½±
            borderLeft: "5px solid var(--info-border)" // å·¦ä¾§é¢œè‰²æ¡
          }
        }).showToast();

      } catch (error) {
        console.error('å¯åŠ¨è‡ªåŠ¨ Cookie è·å–å¤±è´¥:', error); resultDiv.innerHTML = ''; addResultMessage(`âŒ å¯åŠ¨è‡ªåŠ¨è·å–å¤±è´¥: ${error.message}`, 'error'); resultDiv.className = 'error';
        submitButton.disabled = false; autoCookieButton.disabled = false; submitButton.textContent = 'å¼€å§‹æ‰§è¡Œ'; // Re-enable on error
      }
    });

    // --- Form Submission ---
    seatForm.addEventListener('submit', async function (event) {
      event.preventDefault();
      seatNumberInput.style.borderColor = ''; seatNumberInput.style.boxShadow = '';
      resultDiv.innerHTML = ''; resultDiv.className = 'processing'; addResultMessage('æ­£åœ¨éªŒè¯å¹¶æäº¤è¯·æ±‚...', 'processing', true);
      submitButton.disabled = true; autoCookieButton.disabled = true; submitButton.textContent = 'æäº¤ä¸­...'; // Specific text

      if (!wsReady || !websocket || websocket.readyState !== WebSocket.OPEN) { resultDiv.innerHTML = ''; addResultMessage('âŒ WebSocket æœªè¿æ¥ï¼Œè¯·ç­‰å¾…é‡è¿æˆ–åˆ·æ–°ã€‚', 'error'); resultDiv.className = 'error'; submitButton.textContent = 'é€šé“æ–­å¼€'; if (!wsConnectionAttempted) { reconnectAttempts = 0; connectWebSocket(); } return; }

      const modeValue = modeSelect.value;
      const parsedMode = parseInt(modeValue);
      console.log("Mode string:", modeValue, "Parsed:", parsedMode);

      // --- NaN Check for Mode ---
      if (isNaN(parsedMode)) {
        console.error("Mode is NaN."); resultDiv.innerHTML = ''; addResultMessage('âŒ å†…éƒ¨é”™è¯¯ï¼šæ— æ³•è§£ææ“ä½œæ¨¡å¼ã€‚', 'error'); resultDiv.className = 'error';
        submitButton.disabled = false; autoCookieButton.disabled = false; submitButton.textContent = 'å¼€å§‹æ‰§è¡Œ'; return;
      }

      // const data = { mode: parsedMode, cookieStr: cookieInput.value.trim(), libId: parseInt(roomSelect.value), timeStr: timeInput.value.trim(), seatNumber: seatNumberInput.value.trim(), clientId: clientId };

      // console.log("Submitting data:", JSON.stringify(data));

      // --- è·å–æ­£ç¡®çš„æ—¶é—´å­—ç¬¦ä¸² ---
      let timeStrValue = ""; // åˆå§‹åŒ–æ—¶é—´å­—ç¬¦ä¸²
      const timeInputCustom = document.getElementById('timeStr'); // è‡ªå®šä¹‰æ—¶é—´è¾“å…¥æ¡†
      const timeInputMode2 = document.getElementById('timeStrMode2'); // æ¨¡å¼2æ—¶é—´è¾“å…¥æ¡†
      const timeOptionDefault = document.getElementById('timeOptionDefault');
      const timeOptionCustom = document.getElementById('timeOptionCustom');

      if (parsedMode === 1) { // æ˜æ—¥é¢„çº¦æ¨¡å¼
        if (timeOptionDefault.checked) {
          timeStrValue = "21:48:00"; // ä½¿ç”¨ç¡¬ç¼–ç çš„é»˜è®¤æ—¶é—´
          console.log("Mode 1: Using default time:", timeStrValue);
        } else if (timeOptionCustom.checked) {
          timeStrValue = timeInputCustom.value.trim(); // ä½¿ç”¨è‡ªå®šä¹‰è¾“å…¥æ¡†çš„å€¼
          console.log("Mode 1: Using custom time:", timeStrValue);
        } else {
          // ä»¥é˜²ä¸‡ä¸€ï¼Œè™½ç„¶ä¸å¤ªå¯èƒ½å‘ç”Ÿ
          console.error("Mode 1: No time option selected!");
          addResultMessage('âŒ å†…éƒ¨é”™è¯¯ï¼šæœªé€‰æ‹©é¢„çº¦æ—¶é—´é€‰é¡¹ã€‚', 'error');
          submitButton.disabled = false; autoCookieButton.disabled = false; submitButton.textContent = 'å¼€å§‹æ‰§è¡Œ'; return;
        }
      } else if (parsedMode === 2) { // ç«‹å³æŠ¢åº§æ¨¡å¼
        timeStrValue = timeInputMode2.value.trim(); // ä½¿ç”¨æ¨¡å¼2è¾“å…¥æ¡†çš„å€¼
        console.log("Mode 2: Using time input:", timeStrValue);
      }
      // --- End: è·å–æ­£ç¡®çš„æ—¶é—´å­—ç¬¦ä¸² ---

      // ä½¿ç”¨è·å–åˆ°çš„ timeStrValue æ„å»º data å¯¹è±¡
      const data = {
        mode: parsedMode,
        cookieStr: cookieInput.value.trim(),
        libId: parseInt(roomSelect.value),
        timeStr: timeStrValue, // <--- ä½¿ç”¨è¿™é‡Œè®¡ç®—å‡ºçš„ timeStrValue
        seatNumber: seatNumberInput.value.trim(),
        clientId: clientId
      };
      console.log("Submitting data:", JSON.stringify(data)); // è¿™è¡Œä¿ç•™ï¼Œç”¨äºè°ƒè¯•

      let validationError = null;
      if (!data.cookieStr) validationError = 'Cookie ä¸èƒ½ä¸ºç©ºã€‚';
      else if (isNaN(data.libId) || data.libId <= 0) validationError = 'è¯·é€‰æ‹©é˜…è§ˆå®¤ã€‚';
      else if (!data.seatNumber || !/^\d+$/.test(data.seatNumber)) validationError = 'åº§ä½å·ä¸èƒ½ä¸ºç©ºä¸”å¿…é¡»ä¸ºæ•°å­—ã€‚';
      else if (data.mode === 1 && !data.timeStr) validationError = 'æ˜æ—¥é¢„çº¦æ¨¡å¼å¿…é¡»æŒ‡å®šæ‰§è¡Œæ—¶é—´ (HH:MM:SS)ã€‚';
      else if (data.timeStr && !/^\d{2}:\d{2}:\d{2}$/.test(data.timeStr)) validationError = 'æ—¶é—´æ ¼å¼é”™è¯¯ HH:MM:SSã€‚';
      else if (data.mode !== 1 && data.mode !== 2) validationError = 'æ“ä½œæ¨¡å¼é€‰æ‹©æ— æ•ˆã€‚';

      if (validationError) { resultDiv.innerHTML = ''; addResultMessage(`âŒ è¾“å…¥é”™è¯¯: ${validationError}`, 'error'); resultDiv.className = 'error'; submitButton.disabled = false; autoCookieButton.disabled = false; submitButton.textContent = 'å¼€å§‹æ‰§è¡Œ'; return; }

      try {
        const response = await fetch('/api/submit_request', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) });
        const responseData = await response.json();
        if (!response.ok) { const errorDetail = responseData?.detail || responseData?.message || `HTTP Error ${response.status}`; throw new Error(errorDetail); }
        console.log("HTTP Submission successful:", responseData);
        submitButton.textContent = 'å¤„ç†ä¸­...'; // Change text after successful POST, keep disabled
      } catch (error) {
        console.error('æäº¤è¯·æ±‚å¤±è´¥:', error); resultDiv.innerHTML = ''; addResultMessage(`æäº¤è¯·æ±‚å¤±è´¥: ${error.message}`, 'error'); resultDiv.className = 'error';
        submitButton.disabled = false; autoCookieButton.disabled = false; submitButton.textContent = 'å¼€å§‹æ‰§è¡Œ'; // Re-enable on API call failure
      }
    });

    // --- Initial Page Load ---
    updateWebForm();
    loadRooms();

  </script>
</body>

</html>